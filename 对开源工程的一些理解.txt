一、jsoncpp
1. 架构：基于规则的系统，规则表示、解析、查询三要素很齐全
2. 对规则表示value对象的很感兴趣，以测试用例为线索阅读了部分关键代码
（1）内部使用union来表示uint_32、string、array、object等数据类型，使用枚举来标记数据类型
（2）array和object均使用std::map来实现
     map的key为下标，value为值得方法来表示array（其实数组本来就可以看做下标为key的map）
	 object的表示不用解释
3. json标准规则的解析我不感兴趣，没有阅读相关代码
4. 查询也很简单，都是基于map的查询

心得：
1. 从github拉代码：可以获取所有的提交日志；也能知道自己改过什么
2. 以测试用例为线索：
   测试用例非常简单容易阅读；
   测试用例是对整个功能分割成的最小单元，容易理解；
   测试用例一般都是对重点进行测试，易于把握重点
   
   
二、ProcessHacker
1. 架构：数据采集器 + 队列缓存 + 界面，总体就是model + view的架构，完全符合自己推敲的MVC架构
2. 对其进程数据的采集很感兴趣，大致阅读了代码：使用NtQuerySystemInformation来采集信息，不会产生性能问题
3. 网络和服务的的数据采集也值得阅读，了解原理，但是今天没时间了

心得：
1. 从readme入手了解非系统需求， 然后下载vs2019从编译入手，此开源项目直接包含sln文件，比较少见
2. 无单元测试用例，所以此方面无法下手
2. 整体看了进程模型、模块关系，只有一个进程无dll，所以这方面无线索
3. 整体看了工程，只有三个工程，一个静态库phlib，两个exe工程。静态库应该是两个exe的公用代码。
4. 整体浏览phlib的所有类，从类命名上没有找到线索，一般共一个公共lib库很难找到有价值的线索
5. 整体浏览ProcessHacker，从类命名（xxxxlist，xxxtree）找到线索， 
   （1）以Init函数为主线了解界面的的基本情况
   （2）界面必然依赖model，所以特别在意数据结果。在调试的过程中发现了PPH_PROCESS_ITEM数据结构
   （3）以PPH_PROCESS_ITEM为线索找到了创建它的地方，也就找到了最有价值的地方，阅读了其遍历进程信息的线程函数

三、CxImage
1. 接触较早的一个开源库，编译通过并稍微看了一下工程结构。

心得：
1. 工程配置也可以看出一些端倪，CxImage 80%的工程都是静态库，只有少数据几个dll，根据这一信息就可以推敲出对外开放dll了。
2. CxImage的测试用例以实用的Demon形式展现，相比于jsoncpp的单元测试更具有实用性。
3. dll对外导出的接口，如果没有明确以include文件夹的形式出现，那么就需要自己动一下脑筋
   （1）__declspec(dllexport) 
   （2）看Demo中是怎么引入开源工程
   
   
四、QT


五、breakpad
1. 本此项目开发乐游模拟器的时候稍微了解过，这次本来以了解状态机为目的，结果发现其架构称得上是麻雀虽小五脏俱全，非常值得阅读
（1）整体架构分为web服务器和客户端两大构件，典型的c/s架构，客户端和web服务器通信部分使用纯windows api实现
（2）客户端部分也是多进程架构，分为客户-服务端和客户-客户端两大构件，构件通信采用管道（三次握手）和Event（崩溃时）相结合的方式
2. 值得研读的设计
（1）客户-服务端三次握手的状态机，初始化、连接中、连接成功、读数据中、读数据完成、写数据中、写数据完成、读ack确认数据、断开、错误等状态
（2）状态机使用函数实现的典型例子，函数实现的例子同样在cc层也见到过，面向对象却是还没见识过
（3）状态并非很难识别，以流程为中心就可以理解状态机，可以梳理出一些状态
3. 值得了解的window api用法
（1）管道通信api，管道通信就是内核提供的一种应用层通信机制，内核就像是一个共用的场所，大家可以连接在这个里面进行信息交换
（2）RegisterWaitForSingleObject 微软提供线程池，等待事件有信号的api
（3）ReadProcessMemory读取另外一个进程内存数据的api

心得：
1. 由于本项目从前了解过，所以此次并未从readme、编译、测试用例、二进制架构入手，直接从代码目录和类命名入手找到核心的类CrashGenerationServer
2. 以管道建立、读写为流程，阅读了CrashGenerationServer的实现，切勿以状态机为核心，否则会陷入细节出不来
3. 阅读代码后有分析了CrashGenerationServer的多线程模型，虽然使用windows pool很隐蔽，但详细过了一遍；
   一个主线程+windows pool（可能是一个，如果发生并发也可能是多个线程）
4. 也可为自己对外提供组件集合（web服务、客户-服务、客户-客户）积累宝贵经验，具体还没认真研究？？？？？？？